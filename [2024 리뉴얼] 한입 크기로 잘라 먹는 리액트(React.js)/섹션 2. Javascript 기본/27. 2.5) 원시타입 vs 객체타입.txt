27. 2.5) 원시타입 vs 객체타입

원시타입과 객체타입은 값이 저장되거나 복사되는 과정이 서로 다르기 때문에 나눈것이다!

원시타입
	Number, String, Boolean 등... 값 자체로써 변수에 저장되고 복사 된다.

객체타입
	Object, Array, Function 등... 참조값을 통해 변수에 저장되고 복사된다.
---

원시타입
[code]			[Name]			[Memory]
let p1 = 1;			p1				1
let p2 = p1;		p2				1	(실제 메모리의 값은 수정되지 않음)

p2 = 2;			p2				2

---

객체타입 = 가변값
[code]					[Name]			[Memory]
let o1 = { name : "장인기" };	o1				참조값 (0x0000C)
let o2 = o1;				o2

o2.name = "장인기";
o1의 값도 바꾸어버리게 된다!

---

원시타입
	Number, String, Boolean 등... 값 자체로써 변수에 저장되고 복사 된다.
	불변값이다 (메모리 값 수정X)

객체타입
	Object, Array, Function 등... 참조값을 통해 변수에 저장되고 복사된다.
	가변값이다 (메모리 값 수정O)

---

객체 타입 주의사항 1. 의도치 않게 값이 수정될 수 있다.

객체의 참조값을 복사하며, 원본 객체가 수정될 수 있어 위험함.
let o1 = { name : "장인기" };
let o2 = o1;

새로운 객체를 생성하면서 프로퍼티만 따로 복사 하며, 원본 객체가 수정될 일이 없어 안전함.
let o1 = { name : "장인기" };
let o2 = { ...o1 };

---

객체타입 주의사항 2. 객체간의 비교는 기본적으로 참조값을 기준으로 이루어진다.
let o1 = { name : "장인기" };
let o2 = o1;
let o3 = { ...01 };

console.log(o1 === o2);	// True 발생! 왜냐하면 o1과 o2는 Name 값만 다를뿐, 메모리의 참조값은 같기 때문에!

console.log(o1 === o3);	// False 왜냐하면 객체간의 비교 연산은 참조값의 비교 연산으로 이루어 지기 때문임.

// 만약에 참조값이 아닌 프로퍼티를 기준으로 두 객체를 비교하고 싶다면,
console.log(
	JSON.stringify(o1) === JSON.stringify(o3)
);
* JSON.stringify()
	자바스크립트 내장 함수 이며, 객체를 문자열로 변환하는 기능을 수행한다.

얕은비교
o1 === o2	// 참조값을 기준으로 비교

깊은 비교
JSON.stringify(o1) === JSON.stringify(o2)	// 객체를 문자열로 변환하여 비교, JSON.stringify 등의 내장 함수를 이용해야함.

---

객체타입 주의사항 3. 배열과 함수도 사실 객체이다.